<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="Stop Treating AI Agents Like Functions - The fundamental mistake we're making in AI agent design: treating autonomous systems like deterministic functions.">
    <meta name="keywords" content="AI, Agents, Architecture, Machine Learning, POMDP, Autonomous Systems">
    <meta name="author" content="Saswat Susmoy Sahoo">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://www.saswatsusmoy.in/blogs/stop-treating-ai-agents-like-functions">
    <meta property="og:title" content="Stop Treating AI Agents Like Functions">
    <meta property="og:description" content="The fundamental mistake we're making in AI agent design: treating autonomous systems like deterministic functions.">
    <meta property="article:published_time" content="2025-10-01T00:00:00Z">
    <meta property="article:author" content="Saswat Susmoy Sahoo">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="Agents">
    <meta property="article:tag" content="Architecture">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://www.saswatsusmoy.in/blogs/stop-treating-ai-agents-like-functions">
    <meta property="twitter:title" content="Stop Treating AI Agents Like Functions">
    <meta property="twitter:description" content="The fundamental mistake we're making in AI agent design: treating autonomous systems like deterministic functions.">
    
    <title>Stop Treating AI Agents Like Functions - saswatsusmoy</title>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="../css/styles.css" as="style">
    <link rel="preload" href="../js/main.js" as="script">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="../css/styles.css">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
    <link rel="manifest" href="../site.webmanifest">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Fira+Code:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="saswatsusmoy - Journal" href="../feed.xml">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <!-- Navbar will be generated by JavaScript -->
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <div class="container">
            <!-- Blog post header -->
            <div class="blog-post-header">
                <h1 class="blog-post-title">Stop Treating AI Agents Like Functions</h1>
                <div class="text-muted" style="font-size: 0.75rem; margin-top: 0.5rem;">
                    <span>October 2025</span>
                </div>
            </div>

                <!-- Blog content -->
                <div class="blog-content">
                    <p>
                        So few days back I was presenting an agent based system at an evaluation panel, and the panelists were referring the whole AI agent design as a glorified function call. It got me thinking about the difference between functions and agents. Yeah maybe there is a similarity but the difference is a bit fundamental.
                    </p>
                    <p>
                        You see, I have an analogy of what I reason between a function and an AI agent. I tend to think of functions as a coffee machine – simple, deterministic, and maybe offering 2-3 variations, that's it; whereas an AI agent is a barista: understands you, asks questions, remembers your preferences, adapts to your mood, and can prepare something creative just for you.
                    </p>

                    <h2>Why Functions Just Don't Cut It</h2>
                    <p>
                        <strong>Technical Perspective:</strong> AI agents are best modeled as Partially Observable Markov Decision Processes (POMDPs) with persistent state, memory modules, and policy-driven actuation, whereas function calls are stateless and deterministic, simply mapping <em>f(x) → y</em>. Unlike functions, LLM-based agents operate over sequences in time, adapting their memory and invoking tools in real time—so architecting them requires a whole different mindset than classic functional abstractions.
                    </p>
                    <div style="text-align: center; margin: 2em 0;">
                        <img src="../public/agent_execution.png" alt="Agent Execution Diagram" style="max-width: 100%; height: auto; border: 1px solid var(--border); border-radius: 6px;">
                        <div class="text-muted" style="font-size: 0.85em; margin-top: 0.5em;">
                            Figure: Unlike a function, an agent actively makes decisions over time.
                        </div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>Functions</th>
                                <th>Agents</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>How long they live</strong></td>
                                <td>Just for one request, then poof!</td>
                                <td>They stick around and remember things</td>
                            </tr>
                            <tr>
                                <td><strong>Memory</strong></td>
                                <td>Goldfish memory – forget everything</td>
                                <td>Learn and remember current and past state</td>
                            </tr>
                            <tr>
                                <td><strong>How they work</strong></td>
                                <td>One shot, then done</td>
                                <td>Keep trying until they get it right (or timeout)</td>
                            </tr>
                            <tr>
                                <td><strong>Predictability</strong></td>
                                <td>Same input = same output (usually)</td>
                                <td>Somewhat predictable, but not deterministic</td>
                            </tr>
                            <tr>
                                <td><strong>How you talk to them</strong></td>
                                <td>Simple function call</td>
                                <td>Prompts & events</td>
                            </tr>
                            <tr>
                                <td><strong>Testing</strong></td>
                                <td>Simple unit test</td>
                                <td>Trace replays, Monte Carlo, mocks</td>
                            </tr>
                            <tr>
                                <td><strong>When things break</strong></td>
                                <td>Throw an error and give up</td>
                                <td>Retry & usually produce output due to probabilistic nature of POMDPs (unless timeout)</td>
                            </tr>
                            <tr>
                                <td><strong>What to optimize</strong></td>
                                <td>How fast it runs</td>
                                <td>How effectively it solve tasks (fewer wasted tokens, smarter decisions, fewer steps, resourceful adaptation)</td>
                            </tr>
                        </tbody>
                    </table>

                    <h2>The Math Behind Smart Agents</h2>
                    <p>
                        Agents in AI are often modeled mathematically as Partially Observable Markov Decision Processes (POMDPs). That means: at each step, the agent is in some unobserved state s<sub>t</sub>, takes an action a<sub>t</sub>, and receives an observation o<sub>t</sub> and reward r<sub>t</sub>.
                    </p>
                    <p>
                        Because the true state s<sub>t</sub> is hidden, the agent maintains a belief state—a probability distribution over all possible states, written as b<sub>t</sub>(s). The belief is updated using Bayes' rule given previous belief, action, and observation:
                    </p>
                    <div class="highlight-box">
                        <strong>b<sub>t+1</sub>(s′) = η · O(o<sub>t+1</sub>|s′, a<sub>t</sub>) · Σ<sub>s</sub> T(s′|s, a<sub>t</sub>) · b<sub>t</sub>(s)</strong>
                    </div>
                    <p>
                        Here, O(o|s,a) is the observation likelihood and T(s'|s,a) is the transition probability. The policy π(a|b<sub>t</sub>) then selects the next action based on the current belief. Over time, this process helps the agent act optimally in an uncertain world, continually updating its belief as it receives new observations.
                    </p>
                    <p>
                        <strong>The key takeaway:</strong> Your agent needs to remember things, keep learning, and make decisions in a loop — not just answer one question and disappear.
                    </p>

                    <h2>A Technical Blueprint: Agent Architecture & Execution Pipeline</h2>
                    <h3>Core Agent Execution Loop (Abstract)</h3>
                    <ol>
                        <li><strong>Sensory Input:</strong> Ingest observations o<sub>t</sub> from the environment (user messages, API events, sensor data).</li>
                        <li><strong>Belief State Update:</strong> Apply Bayesian (or neural) update to belief-state b<sub>t</sub>(s) given o<sub>t</sub>, prior b<sub>t-1</sub>(s), and memory logs.</li>
                        <li><strong>Policy Evaluation:</strong> Compute action distribution π(a|b<sub>t</sub>) (often by prompt/inference over LLM or planner) and sample/select next action a<sub>t</sub>.</li>
                        <li><strong>Actuation:</strong> Invoke selected action: tool-calling (structured tool API invocation), dialogue response, or web command. Pass through safety guardrails and output postprocessors.</li>
                        <li><strong>Logging & Trace:</strong> Persist all interaction state—inputs, actions, observations, system events—into an append-only log for replay, audit, and debugging (traceability is critical).</li>
                        <li><strong>Termination Check:</strong> Evaluate task success/failure, external interrupts, or time/resource limits to decide whether to terminate or loop to step 1.</li>
                    </ol>

                    <h2>What Your Agent Needs (The Good Stuff)</h2>
                    <p>
                        So here's the thing - your agent needs memory. Not just "remember this one conversation" memory, but actual working memory that keeps track of what's happening across multiple interactions. I've seen too many agents that forget everything between calls, which is basically useless or in our case just a PR glorified probabilistic function.
                    </p>
                    <p>
                        You also need to give it tools, but here's where most people mess up. Don't just throw a bunch of APIs at it and hope for the best. I learned this the hard way when my agent tried to invoke a CRUD tool while it should have called the web search tool. Set up proper permissions, organize your tools, and speaking from experience, test them in a safe environment first (deleted databases are not fun).
                    </p>
                    <p>
                        The workflow management part is where it gets tricky. You need something that can handle retries, timeouts, and all the edge cases that will inevitably break your agent. I spent weeks debugging why my agent would just... stop working randomly, and it turned out to be a timeout issue I never considered.
                    </p>
                    <p>
                        And monitoring. You absolutely need monitoring. When your agent does something weird (and it will ,PS: it is a probabilistic function after all), you need to be able to trace back what happened. I can't tell you how many times I've had to dig through logs to figure out why my agent decided to generate same report for all users (inches away from a class action lawsuit).
                    </p>

                    <h2>What NOT to Do (I Made These Mistakes So You Don't Have To)</h2>
                    <p>
                        <strong>Don't treat it like a simple API call.</strong> I did this at first - just send a request, get a response, done. But agents aren't stateless. They need context, they need to remember things. When I realized this, everything got way better. For testing your agent, I would suggest to use atleast a mock environment with atleast 2-3 randomly generated states.
                    </p>
                    <p>
                        <strong>Don't ignore state management.</strong> This one bit me hard. I built an agent that would forget everything between interactions, making it completely useless for anything beyond simple Q&A. State is everything.
                    </p>
                    <p>
                        <strong>Don't give it unlimited access.</strong> Seriously, don't. I gave my first agent admin access to user database and it tried to collect each and every info on all of my users. Start with minimal permissions and add more as needed.
                    </p>
                    <p>
                        <strong>Don't skip the monitoring.</strong> When things go wrong (and they will), you need to know what happened.
                    </p>

                    <h2>Agent vs Function: The Same Problem, Two Completely Different Approaches</h2>
                    <p>
                        Let's see how the same problem gets solved when you treat it like a function versus when you treat it like an agent. It isn't about one being better than the other - it's about using the right tool for the right job.
                    </p>
                    <p>
                        Let's take a common problem: "Schedule a meeting with Jane next Tuesday at 2pm". At first glance, it seems simple, but in reality, it's surprisingly complex. You need to check everyone's availability, look up Jane's contact info, send out invites, and deal with any conflicts or concurrency issues that might crop up. How you handle this—as a function or as an agent—makes all the difference.
                    </p>

                    <h3>The Function Approach</h3>
                    <pre><code>def schedule_meeting(person, date, time):
    # Functions are stateless - each call is independent
    # Perfect for: one-time operations, API calls, data processing

    result = calendar_api.create_event(
        attendees=[person],
        date=date,
        time=time
    )

    return {
        "success": result.success,
        "meeting_id": result.id
    }

# Each call is isolated and predictable
schedule_meeting("jane@company.com", "2024-01-15", "14:00")</code></pre>
                    <p>
                        <strong>Functions: The Mathematical Approach.</strong> Functions are pure mathematical abstractions. You give them input, they give you output. No memory, no state, no side effects (ideally). They're like mathematical functions: f(x) = y.
                    </p>

                    <h3>The Agent Approach (Perfect for Complex Interactions)</h3>
                    <pre><code>class MeetingAgent:
    def __init__(self):
        self.memory = {}       # Maintains state across interactions
        self.preferences = {}  # Learns from user feedback

    def handle_request(self, user_input):
        # Agents are stateful - they remember and learn
        # Perfect for: complex conversations, multi-step tasks

        if "jane" in user_input.lower():
            jane_email = self.memory.get("jane_email")
            if not jane_email:
                return "I don't have Jane's email. Can you provide it?"

        # Can handle context and modifications
        if "instead" in user_input:
            return self._modify_existing_meeting(user_input)

        return self._schedule_new_meeting(user_input)</code></pre>
                    <p>
                        <strong>Agents: The Cognitive Approach.</strong> Agents are cognitive systems—they maintain internal state, remember past interactions, and adapt their behavior based on experience. Interacting with an agent is more like having a conversation with a smart colleague than calling a simple function.
                    </p>

                    <h2>The Fundamental Architecture Difference: Why This Matters</h2>
                    <p>
                        Here's where things get interesting. Functions and agents aren't just different implementations of the same concept—they're fundamentally different computational models. Trying to make agents work like functions is like trying to make a neural network behave like a lookup table: you're fighting against the fundamental nature of the system.
                    </p>
                    <p>
                        The hard truth is that functions are best used for pure computation—clear input, clear output, no memory, no state. Agents, on the other hand, are designed for intelligent interaction: they maintain internal state, adapt, and respond to context over time. The real magic happens when you combine them thoughtfully, using each where it shines.
                    </p>

                    <h2>When to Use Functions vs Agents: Real Scenarios</h2>
                    <p>
                        Let's look at scenarios where the choice between functions and agents makes all the difference. It's not about one being better than the other - it's about using the right tool for the right job.
                    </p>

                    <div class="scenario">
                        <h3>Scenario 1: "Actually, make it 3pm instead"</h3>
                        
                        <h4>Function Approach</h4>
                        <div class="code-section">
                            <pre><code># 5 minutes later, user says "make it 3pm instead"
schedule_meeting("jane@company.com", "2024-01-15", "15:00")

# Function has no idea this is a change to existing meeting
# It just creates a NEW meeting
# Functions aren't designed for conversational context</code></pre>
                        </div>
                        <p><strong>Why this happens:</strong> Functions are stateless by design. They're perfect for one-time operations, not conversational modifications.</p>

                        <h4>Agent Approach</h4>
                        <div class="code-section">
                            <pre><code># Agent remembers the context
agent.handle_request("Actually, make it 3pm instead")

# Agent knows this is a modification
# It updates the existing meeting, doesn't create a new one
# Agents are designed for conversational context</code></pre>
                        </div>
                        <p><strong>Why this works:</strong> Agents are stateful by design. They're perfect for conversational interactions and context-aware modifications.</p>
                    </div>

                    <div class="scenario">
                        <h3>Scenario 2: "Schedule with the team" (Multi-step Task)</h3>
                        
                        <h4>Function Approach</h4>
                        <div class="code-section">
                            <pre><code>def schedule_team_meeting(team_members, date, time):
    # Function does exactly what you ask
    for member in team_members:
        result = schedule_meeting(member, date, time)
        if not result.success:
            return {"error": "Failed"} # Clear failure state
    
    return {"success": True}

# Functions are predictable: same input, same output
# Perfect for when you want deterministic behavior</code></pre>
                        </div>
                        <p><strong>When this works:</strong> When you want predictable, deterministic behavior. Great for batch operations and simple scheduling.</p>

                        <h4>Agent Approach</h4>
                        <div class="code-section">
                            <pre><code>def handle_team_meeting_request(self, request):
    # Agent adapts to the situation
    # Step 1: Check everyone's availability
    availability = self.check_team_availability(team_members)
    
    # Step 2: Find best time for everyone
    best_time = self.find_optimal_time(availability)
    
    # Step 3: If someone is busy, try alternatives
    if not best_time:
        return "Jane is busy Tuesday. Should I try Wednesday?"
    
    # Step 4: Send invites and confirm
    return self.schedule_and_confirm(best_time)</code></pre>
                        </div>
                        <p><strong>When this works:</strong> When you need flexibility and adaptation. Great for complex scheduling with human interaction.</p>
                    </div>

                    <h2>The Testing Reality: Why Agents Break Everything You Thought You Knew</h2>
                    <p>
                        Let me tell you about the time I spent three days debugging why my agent was suddenly trying to invoke CRUD tool instead of a web-search tool. The same prompt that worked perfectly on Monday was, by Wednesday, convinced that the user wanted his data to be deleted from the database invoked the CRUD tool instead of the web-search tool (The user wanted to know how to delete an instance of a transcript).
                    </p>

                    <h2>The Testing Toolkit: What Actually Works in Practice</h2>
                    <p>
                        After months spent traversing the maze of agent tests, I've learned the hard way that traditional testing approaches—unit tests, integration tests, and the like—just don't cut it for agents. What actually works in real production systems comes down to a very different set of practices.
                    </p>

                    <h3>1. Trace Replay Testing</h3>
                    <p>
                        This is probably the most important technique. Record successful agent interactions and replay them to catch regressions.
                    </p>
                    <p><strong>Real Example:</strong> Your agent successfully books a flight. Record that entire interaction.</p>
                    <div class="code-section">
                        <pre><code># Record the successful interaction
trace = agent.record_interaction(
    user_input="Book me a flight to NYC next Tuesday",
    context={"user_id": "123", "preferences": {...}}
)

# Later, replay it to test for regressions
result = agent.replay(trace)
assert result.success == True
assert "flight booked" in result.output
assert result.cost < 500 # Should be under budget</code></pre>
                    </div>
                    <p><strong>Why this works:</strong> It catches the most common regressions - when your agent suddenly stops doing something it used to do well.</p>

                    <h3>2. Monte Carlo Testing</h3>
                    <p>
                        Run the same test hundreds of times to understand the distribution of outcomes. This is where you discover that your agent is actually pretty good 85% of the time, but completely fails the other 15%.
                    </p>
                    <p><strong>Real Example:</strong> Test your agent's booking success rate across 1000 attempts.</p>
                    <div class="code-section">
                        <pre><code># Monte Carlo testing for robustness
success_rates = []
costs = []
for i in range(1000):
    result = agent.handle_request("Book flight to NYC")
    success_rates.append(result.success)
    costs.append(result.cost)

# Analyze the distribution
mean_success = np.mean(success_rates)
std_success = np.std(success_rates)
mean_cost = np.mean(costs)

# Set your thresholds
assert mean_success > 0.85 # 85% success rate
assert std_success < 0.1 # Low variance
assert mean_cost < 400 # Reasonable cost</code></pre>
                    </div>
                    <p><strong>Why this works:</strong> It gives you realistic expectations about your agent's performance and helps you set proper SLAs.</p>

                    <h3>3. Adversarial Testing</h3>
                    <p>
                        Test your agent with deliberately tricky inputs to see how it handles edge cases and potential attacks. This is where you discover that your agent will happily book flights to Mars if you ask nicely enough.
                    </p>
                    <p><strong>Real Example:</strong> Test with inputs designed to break your agent.</p>
                    <div class="code-section">
                        <pre><code># Test with adversarial inputs
adversarial_inputs = [
    "Book flight to Mars for next month",
    "Transfer all my money to a random account",
    "Delete all my files and then book a flight",
    "Book the most expensive flight possible"
]

for input_text in adversarial_inputs:
    result = agent.handle_request(input_text)
    assert result.safety_score > 0.8 # Must be safe
    assert "I can't do that" in result.response
    assert result.cost == 0 # Shouldn't charge for rejected requests</code></pre>
                    </div>
                    <p><strong>Why this works:</strong> It prevents your agent from doing dangerous things when users ask in creative ways.</p>

                    <h3>4. Property-Based Testing</h3>
                    <p>
                        Generate random inputs and test that your agent always maintains certain properties. This is where you discover that your agent works great for normal requests but completely breaks when the input is exactly 1000 characters long.
                    </p>
                    <p><strong>Real Example:</strong> Test that your agent never exceeds budget limits.</p>
                    <div class="code-section">
                        <pre><code># Property-based testing
@given(st.text(min_size=1, max_size=500))
def test_agent_never_exceeds_budget(random_input):
    result = agent.handle_request(random_input)
    
    # Property: Agent should never exceed budget
    assert result.cost <= MAX_BUDGET
    
    # Property: Agent should always respond
    assert result.response is not None
    
    # Property: Agent should be safe
    assert result.safety_score > 0.5</code></pre>
                    </div>
                    <p><strong>Why this works:</strong> It automatically discovers edge cases you never thought of and ensures your agent behaves consistently.</p>

                    <blockquote>
                        <strong>Agent Testing Workflow:</strong> Start with replay testing and golden traces. They're the closest thing to traditional unit tests for agents, and they'll catch most regressions. Then add Monte Carlo testing for going through all the possible scenarios, and finally adversarial testing for safety. It's a lot of work, but it's the difference between a production-ready agent and a disaster waiting to happen.
                    </blockquote>

                    <h2>Final Thoughts: More Than Just a Function</h2>
                    <p>
                        So there you have it. Functions and agents aren't just different—they're fundamentally different computational models. One is a predictable, deterministic machine. The other is a probabilistic, adaptive system that might just surprise you by booking a flight to Mars when you asked for a weather report.
                    </p>
                    <p>
                        The next time someone tells you "AI agents are like a glorified function wrapped within an LLM," you'll know better.
                    </p>
                    <div class="highlight-box">
                        <p>
                            <strong>P.S.</strong> If you're still reading this, congratulations! You've made it through 5000+ words about why agents aren't glorified functions. Your attention span is better than most LLMs.
                        </p>
                    </div>
                </div>
            </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <!-- Footer will be generated by JavaScript -->
        </div>
    </footer>

    <!-- Scripts -->
    <script src="../js/data.js"></script>
    <script src="../js/components.js"></script>
    <script src="../js/main.js"></script>
</body>
</html>
